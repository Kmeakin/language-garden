-- Combinators

-- The polymorphic identity function
--
-- Also known as the ‘I combinator’ in [combinatory logic].
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
let id : fun (A : Type) -> A -> A :=
  fun _ a := a;

-- A function that always returns the same value
--
-- Also known as the ‘C combinator’ in [combinatory logic].
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
let always : fun (A : Type) (B : Type) -> A -> B -> A :=
  fun _ _ a _ := a;

-- Flip the order of the first two inputs to a function
--
-- Also known as the ‘T combinator’ in [combinatory logic].
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
let flip : fun (A : Type) (B : Type) (C : Type) -> (A -> B -> C) -> (B -> A -> C) :=
  fun _ _ _ a-b-c :=
    fun b a := a-b-c a b;

-- Connect the outputs of one function to the inputs of another function
--
-- Also known as the ‘Z combinator’ in [combinatory logic].
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
let compose : fun (A : Type) (B : Type) (C : Type) -> (A -> B) -> (B -> C) -> (A -> C) :=
  fun _ _ _ a-b b-c :=
    fun a := b-c (a-b a);

-- Fuse two functions with the same input.
--
-- Also known as the ‘S combinator’ in [combinatory logic].
--
-- # References
--
-- * [Why is the S combinator an S?][s-combinator-blog]
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
-- [s-combinator-blog]: https://blog.plover.com/math/combinator-s.html
let fuse : fun (A : Type) (B : Type) (C : Type) -> (A -> B -> C) -> (A -> B) -> (A -> C) :=
  fun _ _ _ a-b-c a-b :=
    fun a := a-b-c a (a-b a);


-- Dependent Combinators

-- Flip the order of the first two inputs to a dependent function
--
-- Also known as the ‘T combinator’ in [combinatory logic].
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
let dep-flip :
  fun (A : Type) (B : Type) (C : A -> B -> Type) ->
  fun (a-b-c : fun (a : A) (b : B) -> C a b) ->
    (fun (b : B) (a : A) -> C a b) :=
      fun _ _ _ a-b-c :=
        fun b a := a-b-c a b;

-- Dependent function composition
--
-- Also known as the ‘Z combinator’ in [combinatory logic].
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
let dep-compose :
  fun (A : Type) (B : A -> Type) (C : fun (a : A) -> B a -> Type) ->
  fun (a-b : fun (a : A) -> B a) ->
  fun (a-b-c : fun (a : A) (b : B a) -> C a b) ->
    (fun (a : A) -> C a (a-b a)) :=
      fun _ _ _ a-b a-b-c :=
        fun a := a-b-c a (a-b a);

-- Dependent fusion
--
-- Also known as the ‘S combinator’ in [combinatory logic].
--
-- # References
--
-- * [Outrageous but Meaningful Coincidences: Dependent type-safe syntax and evaluation][dep-rep]
--   (Described in Section 5 as an infix `_ˢ_` operator)
-- * [Why is the S combinator an S?][s-combinator-blog]
--
-- [combinatory logic]: https://en.wikipedia.org/wiki/Combinatory_logic
-- [dep-rep]: https://personal.cis.strath.ac.uk/conor.mcbride/pub/DepRep/DepRep.pdf
-- [s-combinator-blog]: https://blog.plover.com/math/combinator-s.html
let dep-fuse :
  fun (A : Type) (B : A -> Type) (C : fun (a : A) -> B a -> Type) ->
  fun (a-b-c : fun (a : A) (b : B a) -> C a b) ->
  fun (a-b : fun (a : A) -> B a) ->
    (fun (a : A) -> C a (a-b a)) :=
      fun _ _ _ a-b-c a-b :=
        fun a :=  a-b-c a (a-b a);


-- Booleans

let Bool : Type :=
  fun (Bool : Type) ->
    fun (true : Bool) ->
    fun (false : Bool) ->
      Bool;

let true : Bool :=
  fun Bool true false := true;

let false : Bool :=
  fun Bool true false := false;


let not : Bool -> Bool :=
  fun bool :=
    fun Bool true false :=
      bool Bool false true;


-- Natural numbers

let Nat : Type :=
  fun (Nat : Type) ->
    fun (succ : Nat -> Nat) ->
    fun (zero : Nat) ->
      Nat;

let zero : Nat :=
  fun Nat succ zero := zero;

let succ : Nat -> Nat :=
  fun prev :=
    fun Nat succ zero :=
      succ (prev Nat succ zero);


let add : Nat -> Nat -> Nat :=
  fun n0 n1 Nat succ zero :=
    n0 Nat succ (n1 Nat succ zero);

let mul : Nat -> Nat -> Nat :=
  fun n0 n1 :=
    fun Nat succ zero :=
      n0 Nat (n1 Nat succ) zero;


-- Lists

let List : Type -> Type :=
  fun Elem :=
    fun (List : Type) ->
    fun (nil : List) ->
    fun (cons : Elem -> List -> List) ->
      List;

let nil : fun (Elem : Type) -> List Elem :=
  fun Elem :=
    fun List nil cons := nil;

let cons : fun (Elem : Type) -> Elem -> List Elem -> List Elem :=
  fun Elem head tail :=
    fun List nil cons :=
      cons head (tail List nil cons);


-- Vectors

let Vec : Type -> Nat -> Type :=
  fun Elem len :=
    fun (Vec : Nat -> Type) ->
    fun (nil : Vec zero) ->
    fun (cons : fun (len : Nat) -> Elem -> Vec len -> Vec (succ len)) ->
      Vec len;

let vec-nil : fun (Elem : Type) -> Vec Elem zero :=
  fun Elem :=
    fun Vec nil cons := nil;

let vec-cons : fun (Elem : Type) (len : Nat) -> Elem -> Vec Elem len -> Vec Elem (succ len) :=
  fun Elem len head tail :=
    fun Vec nil cons :=
      cons len head (tail Vec nil cons);


-- Void

let Void : Type :=
  fun (Void : Type) -> Void;

let absurd : fun (A : Type) -> Void -> A :=
  fun A void := void A;


-- Unit

let Unit : Type :=
  fun (Unit : Type) ->
    fun (unit : Unit) ->
      Unit;

let unit : Unit :=
  fun Unit unit := unit;


-- Leibniz equality

-- This states that two things of the same type are equal if every property of
-- one is also a property of the other.
let Eq : fun (A : Type) -> A -> A -> Type :=
  fun A a0 a1 :=
    fun (P : A -> Type) -> P a0 -> P a1;

let refl : fun (A : Type) (a : A) -> Eq A a a :=
  fun A a P := id (P a);


let trans : fun (A : Type) (a0 : A) (a1 : A) (a2 : A) ->
    Eq A a0 a1 -> Eq A a1 a2 -> Eq A a0 a2 :=
  fun A a0 a1 a2 p0 p1 :=
    fun P := compose (P a0) (P a1) (P a2) (p0 P) (p1 P);

let sym : fun (A : Type) (a0 : A) (a1 : A) -> Eq A a0 a1 -> Eq A a1 a0 :=
  fun A a0 a1 p :=
    p (fun a1 := Eq A a1 a0) (refl A a0);


-- Examples

let list1 : List Bool :=
  cons Bool (id Bool true) (nil Bool);

let five : Nat := succ (succ (succ (succ (succ zero))));
let ten : Nat := add five five;
let hundred : Nat := mul ten ten;
let thousand : Nat := mul ten hundred;

let eq_test : Eq Nat hundred hundred := refl Nat hundred;

let eq-id-elim-type : Eq Type ((id Type) Type) Type := refl Type Type;
let eq-id-elim-true : Eq Bool ((id Bool) true) true := refl Bool true;
let eq-id-elim-false : Eq Bool ((id Bool) false) false := refl Bool false;


--

Type
